#-----------------------------
# Note for workshop provided code: please be sure to check through the code before applying it to other projects!
#-----------------------------
# Processing and interpreting single cell RNA-seq data: A one day short-course
# Module 3, Part 1
#------------------------------

The example data for this workshop is from Zebrahub (https://zebrahub.ds.czbiohub.org/) which provides data related to zebrafish development. We will use two time points: one replicate from Day 5 and one replicate from Day 10. To reduce the analysis run time, each sample has been downsampled to 3,000 cells.

We will use the R toolkit Seurat (version 5.0.1). Note that starting with Seurat v5, there are new functions for manipulating layers.

Two sites that have been used extensively in this Module include:

1) The Seurat website (https://satijalab.org/seurat/) includes vignettes, as well as a tutorial that includes an overview of the Seurat analysis pipeline (https://satijalab.org/seurat/articles/pbmc3k_tutorial)

2) The Harvard Chan Bioinformatics Core (HBC) Single-cell RNA-seq data analysis workshop (https://hbctraining.github.io/scRNA-seq_online) 

#------------------------------
# Importing Data
#------------------------------

```{r setup, include=FALSE}
knitr::opts_chunk$set(message = FALSE, warning = FALSE)
```

First load the R libraries used in this Module and set your working directory

```{r load_libraries_set_path}
library(Seurat)
library(ggplot2)
library(tidyverse)

# Set wd to base of workshop repository
here::i_am("README.md")
```

In Module 2, we discussed using Cell Ranger to process 10X data. There are three files generated by Cell Ranger that we will use here: matrix.mtx, features.tsv, and barcodes.tsv. Cell Ranger will generate two directories, one that contains the raw data (raw_feature_bc_matrix) and one that contains data that has been filtered by Cell Ranger (filtered_feature_bc_matrix). For this tutorial, the data comes from the filtered_feature_bc_matrix directory, which is considerably smaller in size than that of the raw_feature_bc_matrix directory. 

1) matrix.mtx: contains count values where the rows are the genes and the columns are the cells (labeled by their barcode) 
2) features.tsv: a gene list (ie gene symbols) and the list order matches that found in the matrix.mtx file
3) barcodes.tsv: a cell barcode list and the list order matches that in the matrix.mtx file

We will read in the data using the Seurat Read10X() function. CreateSeuratObject() will be used to initialize a Seurat object for each time point. Methods for interacting with the objects, such as for subsetting cells, can be found with ?SeuratObject::subset

The Seurat object can store count matrices, transformed data, annotations, etc. and provides a source for accessing this data. An option in the CreateSeuratObject() function is to include only those genes that are found in at least a specified number of cells (min.cells) or to include only those cells that have at least a specified number of genes (min.features). At this point we will not use these filters, and will save filtering for later on during the QC steps. 

More information about importing data and generating SeuratObjects for multiple samples can be found here:
https://hbctraining.github.io/scRNA-seq_online/lessons/03_SC_quality_control-setup.html

```{r load_data} 
# Create Seurat objects for Day 5 and Day 10

for (file in c("Day_5", "Day_10")){
        srat.data <- Read10X(data.dir = here::here("_temp_data/Cell_Ranger/", file))
        srat.obj <- CreateSeuratObject(counts = srat.data, project = file)
        
        assign(file, srat.obj)
}


# Generate a single Seurat object called srat for Day 5 and Day 10
# Each time point has 25,432 genes and 3000 cells
srat <- merge(x = Day_5, 
              y = Day_10, 
              add.cell.id = c("Day_5", "Day_10")
              )

```

We now have the data from Cell Ranger loaded into a single Seurat object, where the two time points are stored in separate layers. Downstream normalization for example can be performed for each layer separately. It can be seen that there are 13 slots and a specific slot can be accessed with the @ symbol. We can see that for @assays, the gene and cell count attributes are displayed. There are different ways to access the data in this slot (https://github.com/satijalab/seurat/wiki/Assay). Other slots do not yet contain data, but may be filled as additional steps are performed, such as data transformations. 

Because the sequencing depth per cell is low, only a fraction of the transcriptome is captured for each cell. It can be seen that in the count matrix below, that genes that have a 0 count are shown as '.'. Because of the large number of 0s in these count matrices, Seurat uses a sparse-matrix representation. A count value of 0 could represent that a gene is either unexpressed or undetected. 

```{r seurat_objects}

# the available slots are after the @ symbol
slotNames(srat)
srat@assays

# Find the layers that exist in object
Layers(srat[["RNA"]])

# Access gene number in count matrix
# Other possibilities .... ncol, rowMeans, colMeans, rowSums, colSums, rownames, colnames etc. 
nrow(srat[["RNA"]])
nrow(srat@assays$RNA)

# View the count matrix (five rows & five columns) for Day 5
srat[["RNA"]]$counts.Day_5[1:5,1:5]

```

We'd like to explore the quality of the cells below for the two time points. Two metrics that can be used to identify low quality cells are nCount_RNA and nFeature_RNA. These metrics can be found in the meta.data slot in the Seurat object. As with the assays slot, there is more than one way to access the data in the meta.data slot. 

nCount_RNA: number of UMIs per cell
nFeature_RNA: number of genes per cell 
orig.ident: sample identity

One final check is the number of cells for the two time points. Because we have already subsampled these samples to keep only 3000 cells for the workshop, this is the number that we would expect for Day 5 and for Day 10. If the data had not been subsampled however, it would be helpful to know how many cells exist for each sample. The number of cells may be lower or higher than that which was loaded for 10X for a variety of reasons. The 10X cell capture rate is around 65%. If the observed cell number is higher than what might be expected, it is possible that some of the hydrogel beads contained more than one barcode, or that some barcoded beads didn't contain a cell. 


```{r seurat_object_metadata}

# Examples of ways to access metadata
head(srat[[]], 5)
head(srat@meta.data, 5)

# columns that currently exist in the metadata
colnames(srat[[]])

# The number of cells for Day 5 and Day 10 (subsampled to 3000)
table(srat$orig.ident)

```

#------------------------------
# QC -- Identify low quality cells
#------------------------------
# Note: The code for the density and joint filtering plots is based on the HBC tutorial 
# https://hbctraining.github.io/scRNA-seq_online/lessons/04_SC_quality_control.html)
#------------------------------

There are a variety of plot types which can be used to gain insight into the quality of the cells and whether filtration steps might be needed. Scatter plots can be used to visualize the relationship between the number of UMIs and the number of genes. Cells that have either a very low number of genes, potentially due to low quality cells or empty droplets, or a very high number of genes, potentially due to cell doublets, can be filtered before downstream analyses. The scatter plots below show that there are no cells that have a UMI count less than 500. This is due to filtering that is performed by Cell Ranger and included with the filtered_feature_bc_matrix directory, where it has removed cells that have fewer than 500 UMIs (https://www.10xgenomics.com/analysis-guides/common-considerations-for-quality-control-filters-for-single-cell-rna-seq-data). We can confirm this with the tapply function, which shows that the minimum number of UMIs for either day is 500. It also shows that both the UMI median and the mean are quite a bit smaller for Day 5 than for Day 10. 

```{r, scatter_plots}

# Visualize relationships with scatter plots
FeatureScatter(srat,
               feature1 = "nCount_RNA",
               feature2 = "nFeature_RNA",
               pt.size = 1) +
  geom_vline(xintercept = c(500)) +
  coord_cartesian(xlim = c(0, 50000), ylim = c(0,7500))

# UMI stats
tapply(srat$nCount_RNA, srat$orig.ident, summary) 

# Gene stats
tapply(srat$nFeature_RNA, srat$orig.ident, summary)

```

Another useful type of plot for visualization here is a density plot. Below is a density plot for nFeature_RNA, where it can be seen that the Day 5 and the Day 10 profiles differ quite a bit. The Day_5 distribution shows that a lot of cells have approximately 450 genes, which is a relatively low number per cell. The Day 10 distribution is more bimodal, where it has a small peak for those cells that have a low number of genes (~300), and then a second peak for those cells that have a higher number of genes (~2000). Likely there is a subset of low-quality cells in both Day 5 and Day 10. A density plot can also be generated for nCount_RNA. This plot shows that there again is a large number of cells for Day 5 that have a relatively low UMI count, with a peak around 600. This is not that much higher than the pre-filtered cutoff of 500 that was used by Cell Ranger.

```{r, density_plots}
# Generate a data frame from the metadata
metadata_df <- srat@meta.data
dim(metadata_df)

# Density plot for nFeature_RNA
# Purple dashed line : peak for Day 10
# Blue dashed line : peak for Day 5
# Orange dashed line : Day 5 density is approaching 0
metadata_df %>% 
  	ggplot(aes(color=orig.ident, x=nFeature_RNA, fill= orig.ident)) + 
  	geom_density(alpha = 0.5) + 
  	theme_classic() +
  	scale_x_log10() + 
    geom_vline(color = "purple", linetype = "dashed", aes(xintercept = 300)) +
  	geom_vline(color = "blue", linetype= "dashed", aes(xintercept = 450)) +
    geom_vline(color = "orange", linetype = "dashed", aes(xintercept = 5000))

# Density plot for nCount_RNA
# Purple dashed line : min cutoff
# Blue dashed line : peak for Day 5
# Orange dashed line : Day 5 density is approaching 0
metadata_df %>% 
  	ggplot(aes(color=orig.ident, x=nCount_RNA, fill= orig.ident)) + 
  	geom_density(alpha = 0.5) + 
    theme_classic() +
    scale_x_log10() + 
    geom_vline(color = "purple", linetype= "dashed", aes(xintercept = 500)) +
  	geom_vline(color = "blue", linetype= "dashed", aes(xintercept = 600))+
    geom_vline(color = "orange", linetype = "dashed", aes(xintercept = 25000))

```

Another metric that is helpful for identifying potentially problematic cells is the fraction of counts that are associated with mitochondrial (mt) genes. Cells that have low quality or that are dying often will have a high fraction of mt counts. First we need to identify which genes in our data come from mt genes and in this particular annotation, they start with "mt-". We can then use the Seurat function PercentageFeatureSet() to calculate the percentage of mt counts for each cell (see ?PercentageFeatureSet for more details). We can now see that the mt percentage has been added to the metadata as a new column. The density plot below shows that both days have cells whose counts include >20% mt. 


```{r, mt_percentage}

# Add the percent.mt to the meta.data
# The mitochondrial genes start with "mt-"
srat[["percent.mt"]] <- PercentageFeatureSet(srat, pattern = "^mt-")
colnames(srat[[]])

# Generate new data frame w/ mt
metadata_df_w_mt <- srat@meta.data 

# Density plot for mt
# Blue dashed line : 15% mt
# Purple dashed line : 20% mt
metadata_df_w_mt %>% 
  	ggplot(aes(color=orig.ident, x=percent.mt, fill=orig.ident)) + 
  	geom_density(alpha = 0.3) + 
  	theme_classic() +
  	geom_vline(color = "blue", linetype= "dashed", aes(xintercept = 15)) + 
    geom_vline(color = "purple", linetype = "dashed", aes(xintercept = 20))

```

To get a sense for how the mt percentage correlates with those cells that have low UMI and gene counts, we can generate a joint filtering figure for all three metrics. 

```{r, joint_figure}

# The dashed lines show the filter cutoff values that will be applied in the next step
# Blue dashed line : nCount min threshold (2,000)
# Orange dashed line : nCount max threshold (25,000)
# Purple dashed line : nFeature min threshold (700)
# Black dashed line : nFeature max threshold (5,000)
metadata_df_w_mt %>% 
  	ggplot(aes(x=nCount_RNA, y=nFeature_RNA, color=percent.mt)) + 
  	geom_point() + 
    scale_colour_gradient(low = "lightblue", high = "darkblue") +
  	scale_x_log10() + 
  	scale_y_log10() + 
  	geom_vline(color = "blue", linetype= "dashed", aes(xintercept = 2000)) +
    geom_vline(color = "orange", linetype= "dashed", aes(xintercept = 25000)) +
    geom_hline(color = "purple", linetype = "dashed", aes(yintercept = 700)) +
    geom_hline(color = "black", linetype = "dashed", aes(yintercept = 5000)) +
  	facet_wrap(~orig.ident)

```

#------------------------------
# Cell Filtering
#------------------------------
The filtering parameters selected are dependent upon the project. Filtering can be performed iteratively, where obtaining cell annotations can be helpful in identifying biologically relevant cells before filtering cells from a dataset. An interesting conversation regarding filter threshold selection can be seen here: https://github.com/satijalab/seurat/issues/3396

For this tutorial, we will filter the cells based on the above plots, where it can be seen that there was a fairly high fraction of cells that had a low UMI and gene count, and a high mt fraction. We can use the VlnPlot() function to generate a plot for the mt fraction, nCount_RNA and nFeature_RNA for the filtered data. 

```{r, filter_cells}

# Filter for UMI, gene, mt
srat.filtered <- subset(x = srat, 
                    subset = (nCount_RNA > 2000 & nCount_RNA < 25000) & 
                    (nFeature_RNA > 700 & nFeature_RNA < 5000) & 
                    (percent.mt < 15))


# Generate violin plot
VlnPlot(srat.filtered, features = c("nFeature_RNA", "nCount_RNA", "percent.mt"))

# Or on a log scale
VlnPlot(srat.filtered, features = c("nFeature_RNA", "nCount_RNA", "percent.mt"), log = TRUE)

# Number of remaining cells
table(srat.filtered$orig.ident)

```

How do the cutoff parameters for nCount_RNA, nFeature_RNA, and percent.mt compare with those used by Zebrahub?
Day 5: https://zebrahub.ds.czbiohub.org/cbg?name=cbg_5dpf
Day 10: https://zebrahub.ds.czbiohub.org/cbg?name=cbg_10dpf


There are additional quality control checks that can be performed. For example, one could calculate the proportion of data that comes from the most observed gene to examine whether it is higher than might be expected. See more here:
https://www.bioinformatics.babraham.ac.uk/training/10XRNASeq/seurat_workflow.html

In addition to cell filtering, one could also perform gene filtering. With this type of filter, one could reduce the number of rows in the count matrix by removing genes with very low expression. There are different methods that one could use, where one option is shown in the Seurat tutorial where the 'min.cells' parameter is specified in the CreateSeuratObject() function. Other gene filtering methods are discussed here:

1) https://ucdavis-bioinformatics-training.github.io/2022-July-Single-Cell-RNA-Seq-Analysis/data_analysis/scRNA_Workshop-PART2
2) https://hbctraining.github.io/scRNA-seq_online/lessons/04_SC_quality_control.html

#------------------------------
# Save object (optional)
# Note: we will not use this seurat object in the remaining modules
#------------------------------
```{r save_object}
saveRDS(srat.filtered, file="workshop_module3_part1.rds")
```

